<head><link rel="stylesheet"href="c++.css"></head>
<div id="page-layout" class="dark">
            <div id="content-layout">
                <div id="menu-layout">
                    <nav id="navbar">
                        <input class="menu-btn" type="checkbox" id="menu-btn" />
                        <label class="menu-icon" for="menu-btn"><span class="navicon"></span></label>
                        <header>C++ Programming Language</header>
                        <ul class="menu">
                            <li><a href="#introduction" class="nav-link">Introduction</a></li>
                            <li><a href="#learning_c++" class="nav-link">Learning C++</a></li>
                            <li><a href="#programming_in_c++" class="nav-link">Programming in C++</a> </li>
                            <li><a href="#the_basics" class="nav-link">The Basics</a></li>   
                            <li><a href="#hello,_world!" class="nav-link">Hello, World!</a></li>
                            <li><a href="#types_and_variables" class="nav-link">Types and Variables</a></li>
                            <li><a href="#operators" class="nav-link">Operators</a></li>
                            <li><a href="#constants" class="nav-link">Constants</a></li>
                            <li><a href="#pointers,_arrays_and_loops" class="nav-link">Pointers, Arrays and Loops</a></li>
                            <li><a href="#references" class="nav-link">References</a></li>
                        </ul>
                        <button class="theme-toggle-button">
                            <svg class="sun-moon-icon" style="width:24px;height:24px" viewBox="0 0 24 24">
                                <path fill="currentColor" d="M7.5,2C5.71,3.15 4.5,5.18 4.5,7.5C4.5,9.82 5.71,11.85 7.53,13C4.46,13 2,10.54 2,7.5A5.5,5.5 0 0,1 7.5,2M19.07,3.5L20.5,4.93L4.93,20.5L3.5,19.07L19.07,3.5M12.89,5.93L11.41,5L9.97,6L10.39,4.3L9,3.24L10.75,3.12L11.33,1.47L12,3.1L13.73,3.13L12.38,4.26L12.89,5.93M9.59,9.54L8.43,8.81L7.31,9.59L7.65,8.27L6.56,7.44L7.92,7.35L8.37,6.06L8.88,7.33L10.24,7.36L9.19,8.23L9.59,9.54M19,13.5A5.5,5.5 0 0,1 13.5,19C12.28,19 11.15,18.6 10.24,17.93L17.93,10.24C18.6,11.15 19,12.28 19,13.5M14.6,20.08L17.37,18.93L17.13,22.28L14.6,20.08M18.93,17.38L20.08,14.61L22.28,17.15L18.93,17.38M20.08,12.42L18.94,9.64L22.28,9.88L20.08,12.42M9.63,18.93L12.4,20.08L9.87,22.27L9.63,18.93Z" />
                            </svg>
                        </button>
                    </nav>
                </div>
                <main id="main-doc">
                    <section id="introduction" class="main-section">
                        <header>Introduction</header>
                        <article>
                            <p>
                                C++ is a general-purpose programming language emphasizing the design and use of type-rich, lightweight abstractions. It is particularly suited for resource-constrained applications, such as those found in software infrastructures. C++ rewards the programmer who takes the time to mastertechniques for writing quality code. C++ is a language for someone who takes the task of programming seriously. Our civilization depends critically on software; it had better be quality software.
                            </p>
                        </article>
                    </section>
            
                    <section id="learning_c++" class="main-section">
                        <header>Learning C++</header>
                        <article>
                            <p>
                                The most important thing to do when learning C++ is to focus on fundamental concepts (such as type safety, resource management, and invariants) and programming techniques (such as resource management using scoped objects and the use of iterators in algorithms) and not get lost in language-technical details. <br>
                                <br>
                                The purpose of learning a programming language is to become a better programmer, that is, to become more effective at designing and implementing new systems and at maintaining old ones. For this, an appreciation of programming and design techniques is far more important than understanding all the details. The understanding of technical details comes with time and practice.
                            </p>
                        </article>
                    </section>
            
                    <section id="programming_in_c++" class="main-section">
                        <header>Programming in C++</header><p></p>
                        <article>
                            <p>
                                The question "How does one write good programs in C++?" is very similar to the question "How does one write good English prose?".There are two answers: "Know what you want to say" and "Practice. Imitate good writing." Both appear to be as appropriate for C++ as they are for English – and as hard to follow.<br>
                                <br>
                                The main ideal for C++ programming – as for programming in most higher-level languages – is to express concepts (ideas, notions, etc.) from a design directly in code:
                            </p>
                            <ol>
                                <li>Represent ideas directly in code.</li>
                                <li>Represent relationships among ideas directly in code (e.g., hierarchical, parametric, and ownership relationships).</li>
                                <li>Represent independent ideas independently in code.</li>
                                <li>Keep simple things simple (without making complex things impossible).</li>
                                <li>Prefer statically type-checked solutions (when applicable).</li>
                                <li>Keep information local (e.g., avoid global variables, minimize the use of pointers).</li>
                                <li>Don’t overabstract (i.e., don’t generalize, introduce class hierarchies, or parameterize beyond obvious needs and experience)</li>
                            </ol>
                        </article>
                    </section>
            
                    <section id="the_basics" class="main-section">
                        <header>The Basics</header>
                        <article>
                            <p>
                                C++ is a compiled language. For a program to run, its source text has to be processed by a compiler, producing object files, which are combined by a linker yielding an executable program. A C++ program typically consists of many source code files (usually simply called source files)
                            </p>
                            <figure>
                                <img src="https://marcoselvatici.github.io/WASM_tutorial/ref/compile.gif" alt="image of how a c++ program compiles">
                                <figcaption>
                                    Each C++ source file needs to be compiled into an object file. The object files resulting from the compilation of multiple source files are then linked into an executable, a shared library, or a static library (the last of these being just an archive of object files). C++ source files generally have the .cpp, .cxx or .cc extension suffixes. <a href="https://www.toptal.com/c-plus-plus/c-plus-plus-understanding-compilation">Learn More.</a>
                                </figcaption>
                            </figure>
                            <p>
                                An executable program is created for a specific hardware/system combination; it is not portable, say, from a Mac to a Windows PC. When we talk about portability of C++ programs, we usually mean portability of source code; that is, the source code can be successfully compiled and run on a variety of systems.<br>
                                <br>
                                The ISO C++ standard defines two kinds of entities:
                            </p>
                            <ul>
                                <li>Core language features, such as built-in types (e.g., <code class="emphasis_text">char</code> and <code class="emphasis_text">int</code>) and loops (e.g., <code class="emphasis_text">for</code>-statements and <code class="emphasis_text">while</code>-statements)</li>
                                <li>Standard-library components, such as containers (e.g., <code class="emphasis_text">vector</code> and <code class="emphasis_text">map</code>) and I/O operations (e.g., <code class="emphasis_text"><<</code> and <code class="emphasis_text">getline()</code>)</li>
                            </ul>
                            <p>
                                The standard-library components are perfectly ordinary C++ code provided by every C++ implementation. That is, the C++ standard library can be implemented in C++ itself (and is with very minor uses of machine code for things such as thread context switching). This implies that C++ is sufficiently expressive and efficient for the most demanding systems programming tasks. C++ is a statically typed language. That is, the type of every entity (e.g., object, value, name, and expression) must be known to the compiler at its point of use. The type of an object determines the set of operations applicable to it.
                            </p>
                        </article>
                    </section>
            
                    <section id="hello,_world!" class="main-section">
                        <header>Hello, world!</header>
                        <article>
                            <code>
                                int main() { }<span class="tab">//the minimal C++ program</span>

                            </code>
                            <p>
                                This defines a function called <code class="emphasis_text">main</code>, which takes no arguments and does nothing. Curly braces,<code class="emphasis_text">{ }</code>, express grouping in C++. Here, they indicate the start and end of the function body. The double slash, <code class="emphasis_text">//</code>, begins a comment that extends to the end of the line. A comment is for the human reader; the compiler ignores comments.<br>
                                <br>
                                Every C++ program must have exactly one global function named <code class="emphasis_text">main()</code>. The program starts
                                by executing that function. The <code class="emphasis_text">int</code> value returned by <code class="emphasis_text">main()</code>, if any, is the program’s return value to "the system". If no value is returned, the system will receive a value indicating successful completion. A nonzero value from <code class="emphasis_text">main()</code> indicates failure. Not every operating system and execution environment make use of that return value: Linux/Unix-based environments often do, but Windows-based environments rarely do.<br>
                                <br>
                                Typically, a program produces some output. Here is a program that writes <code class="emphasis_text">Hello, World!</code> :
                            </p>
                            <code>
                                #include &lt;iostream&gt;

                            int main()
                                {
                                    <span class="tab">std::cout << "Hello, World!";</span>
                                }
                                
                            </code>
                            <p>
                                The line <code class="emphasis_text">&lt;#include iostream&gt;</code> instructs the compiler to include the declarations of the standard stream I/O facilities as found in iostream. Without these declarations, the expression <code class="emphasis_text">std::cout<< "Hello, World!\n"</code> would make no sense. The operator <code class="emphasis_text"><<</code> ("put to") writes its second argument onto its first. In this case, the string literal <code class="emphasis_text">"Hello, World!\n"</code> is written onto the standard output stream <code class="emphasis_text">std::cout</code> A string literal is a sequence of characters surrounded by double quotes. In a string literal, the backslash character <code class="emphasis_text">\</code> followed by another character denotes a single "special character". In this case, <code class="emphasis_text">\n</code> is the newline character, so that the characters written are <code class="emphasis_text">Hello, World!</code> followed by a newline.<br>
                                <br>
                                The <code class="emphasis_text">std::</code> specifies that the name <code class="emphasis_text">cout</code> is to be found in the standard-library namespace. I usually leave out the <code class="emphasis_text">std::</code> when discussing standard features.<br>
                                <br>
                                Essentially all executable code is placed in functions and called directly or indirectly from <code class="emphasis_text">main()</code>. For example:
                            </p>
                            <code>
                                #include &lt;iostream&gt; 

                                using namespace std;<span class="tab">//make names form std visible without std::</span> 
                                
                                double square(double x)<span class="tab">//square a double precision floating-point number</span>
                                {
                                    <span class="tab">return x * x;</span>
                                }
                                
                                void print_square(double x)
                                {
                                    <span class="tab">cout << "the square of " << x << "is " << square(x) << "\n";</span>
                                }
                                
                                int main()
                                {
                                    <span class="tab"></span> print_square(1.234);<span class="tab"> //print: the square of 1.234 is 1.52276</span>
                                }

                            </code>
                            <p>
                                A "return type" <code class="emphasis_text">void</code> indicates that a function does not return a value.
                            </p>
                        </article>
                    </section>
            
                    <section id="types_and_variables" class="main-section">
                        <header>Types and Variables</header>
                        <article>
                            <p>
                                Every name and every expression has a type that determines the operations that may be performed on it. For example, the declaration:
                            </p>
                            <code>
                                int inch;

                            </code>
                            <p>
                                <span class="tab"></span>specifies that <code class="emphasis_text">inch</code> is of type <code class="emphasis_text">int</code>; that is, <code class="emphasis_text">inch</code> is an integer variable. A declaration is a statement that introduces a name into the program. It specifies a type for the named entity:
                            </p>
                            <ul>
                                <li>A <i>type</i> defines a set of possible values and a set of operations (for an object)</li>
                                <li>An <i>object</i> is some memory that holds a value of some type.</li>
                                <li>A <i>value</i> is a set of bits interpreted according to a type</li>
                                <li>A <i>variable</i> is a named object.</li>
                            </ul>
                            <p>
                                C++ offers a variety of fundamental types. For example:
                            </p>
                            <code>
                                bool<span class="tab">// Boolean, possible values are true and false</span><span class="tab">
                                
                                char<span class="tab">// character, for example, 'a', ' z', and '9'</span>
                                
                                int<span class="tab">// integer, for example, 1, 42, and 1066</span>
                                
                                double<span class="tab">// double-precision floating-point number, for example, 3.14 and 299793.0</span>
                            </code>
                            <p>
                                When defining a variable, you don’t actually need to state its type explicitly when it can be deduced from the initializer:
                            </p>
                            <code>
                                auto b = true;<span class="tab">// a bool</span>
                                
                                auto ch = 'x';<span class="tab">// a char</span>
                                
                                auto i = 123;<span class="tab">// an int</span>
                                
                                auto d = 1.2;<span class="tab">// a double</span>
                                
                                auto z = sqrt(y);<span class="tab">// z has the type of whatever sqrt(y) returns</span>

                            </code>
                            <p>
                                With <code class="emphasis_text">auto</code>, we use the <code class="emphasis_text"> =</code> syntax because there is no type conversion involved that might cause problems. We use <code class="emphasis_text">auto</code> where we don’t have a specific reason to mention the type explicitly.<br>
                                <br>
                                In assignments and in arithmetic operations, C++ performs all meaningful conversions between the basic types so that they can be mixed freely:
                            </p>
                            <code>
                                void some_function()<span class="tab">// function that doesn't return a value</span>
                                {
                                    <span class="tab">double d = 2.2;</span><span class="tab">// initialize floating-point number</span>
                                    
                                    <span class="tab">int i = 7;</span><span class="tab">// initialize integer</span>
                                    
                                    <span class="tab">d = d+i;</span><span class="tab">// assign sum to d</span>
                                    
                                    <span class="tab">i = d*i;</span><span class="tab">// assign product to i (truncating the double d*i to an int)</span>
                                }
                            </code>
                            <p>
                                Note that <code class="emphasis_text"> =</code> is the assignment operator and <code class="emphasis_text">==</code> tests equality. <br>
                                <br>
                                C++ offers a variety of notations for expressing initialization, such as the <code class="emphasis_text"> =</code> used above, and a universal form based on curly-brace-delimited initializer lists:
                            </p>
                            <code>
                                double d1 = 2.3;
                                double d2 {2.3};
                                        
                                
                                complex&lt;double&gt; z = 1;<span class="tab">// a complex number with double-precision floating-point scalars</span>
                                
                                complex&lt;double&gt; z2 {d1,d2};
                                
                                complex&lt;double&gt; z3 = {1,2};<span class="tab">// the = is optional with { ... }</span>
                                
                                
                                vector&lt;int&gt; v {1,2,3,4,5,6};<span class="tab">// a vector of int</span>

                            </code>
                            <p>
                                The <code class="emphasis_text"> =</code> form is traditional and dates back to C, but if in doubt, use the general <code class="emphasis_text">{}</code>&#8211;list form. If nothing else, it saves you from conversions that lose information:
                            </p>
                            <code>
                                int i1 = 7.2;<span class="tab">// i1 becomes 7</span>
                                
                                int i2 {7.2};<span class="tab">// error : floating-point to integer conversion</span>
                                
                                int i3 = {7.2};<span class="tab">// error : floating-point to integer conversion (the = is redundant)</span>
                                
                            </code>
                            <p>
                                A constant cannot be left uninitialized and a variable should only be left uninitialized in extremely rare circumstances. Don’t introduce a name until you have a suitable value for it. Userdefined types (such as <code class="emphasis_text">string</code>, <code class="emphasis_text">vector</code>, <code class="emphasis_text">Matrix</code>, <code class="emphasis_text">Motor_controller</code>, and <code class="emphasis_text">Orc_warrior</code>) can be defined to be implicitly initialized.
                            </p>
                        </article>
                    </section>
            
                    <section id="operators" class="main-section">
                        <header>Operators</header>
                        <article>
                            <h2>Arithmetic operators</h2>
                            <p>The arithmetic operators can be used for appropriate combinations of these types:</p>
                            <code>
                                x+y<span class="tab">// plus</span>
                                
                                +x <span class="tab">// unary plus</span>
                                
                                x−y<span class="tab">// minus</span>
                                
                                −x <span class="tab">// unary minus</span>
                                
                                x∗y<span class="tab">// multiply</span>
                                
                                x/y<span class="tab">// divide</span>
                                
                                x%y<span class="tab">// remainder (modulus) for integers</span>

                            </code>
                            <h2>Comparision operators</h2>
                            <code>
                                x==y<span class="tab">// equal</span>

                                x!=y<span class="tab">// not equal</span>

                                x&lt;y<span class="tab">// less than</span>

                                x&gt;y<span class="tab">// greater than</span>

                                x<=y<span class="tab">// less than or equal</span>

                                x>=y<span class="tab">// greater than or equal</span>

                            </code>
                            <h2>Increment and Decrement Operators</h2>
                            <p>
                                C++ offers more specific operations for modifying a variable. These operators are concise, convenient, and very frequently used:
                            </p>
                            <code>
                                x+=y<span class="tab">// x = x+y</span>
                                
                                ++x <span class="tab">// increment: x = x+1</span>
                                
                                x−=y<span class="tab">// x = x-y</span>
                                
                                −−x <span class="tab">// decrement: x = x-1</span>
                                
                                x∗=y<span class="tab">// scaling: x = x*y</span>
                                
                                x/=y<span class="tab">// scaling: x = x/y</span>
                                
                                x%=y<span class="tab">// x = x%y</span>

                            </code>
                        </article>
                    </section>
            
                    <section id="constants" class="main-section">
                        <header>Constants</header>
                        <article>
                            <p>C++ supports two notions of immutability:</p>
                            <ul>
                                <li><code class="emphasis_text">const</code>: meaning roughly "I promise not to change this value". This is used primarily to specify interfaces, so that data can be passed to functions without fear of it being modified. The compiler enforces the promise made by <code class="emphasis_text">const</code></li>
                                <li><code class="emphasis_text">constexpr</code>: meaning roughly ‘‘to be evaluated at compile time’’ (§10.4). This is used primarily to specify constants, to allow placement of data in memory where it is unlikely to be corrupted, and for performance</li>
                            </ul>
                            <code>
                                const int dmv = 17;<span class="tab">// dmv is a named constant</span>

                                int var = 17;<span class="tab">// var is not a constant</span>
                                
                                constexpr double max1 = 1.4∗square(dmv);<span class="tab">// OK if square(17) is a constant expression</span>
                                
                                constexpr double max2 = 1.4∗square(var);<span class="tab">// error : var is not a constant expression</span>
                                
                                const double max3 = 1.4∗square(var);<span class="tab">// OK, may be evaluated at run time</span>

                            </code>
                            <p>
                                For a function to be usable in a constant expression, that is, in an expression that will be evaluated by the compiler, it must be defined <code class="emphasis_text">constexpr</code>. For example:
                            </p>
                            <code>
                                constexpr double square(double x) { return x∗x; }

                            </code>
                            <p>
                                To be <code class="emphasis_text">constexpr</code>, a function must be rather simple: just a <code class="emphasis_text">return</code>&#8211;statement computing a value. A <code class="emphasis_text">constexpr</code> function can be used for non-constant arguments, but when that is done the result is not a constant expression. We allow a <code class="emphasis_text">constexpr</code> function to be called with non-constant-expression arguments in contexts that do not require constant expressions, so that we don’t hav e to define essentially the same function twice: once for constant expressions and once for variables.<br>
                                <br>
                                In a few places, constant expressions are required by language rules (e.g., array bounds, case labels, some template arguments, and constants declared using <code class="emphasis_text">constexpr</code>). In other cases, compile-time evaluation is important for performance. Independently of performance issues, the notion of immutability (of an object with an unchangeable state) is an important design concern.
                            </p>
                        </article>
                    </section>
            
                    <section id="pointers,_arrays_and_loops" class="main-section">
                        <header>Pointers, Arrays and Loops</header>
                        <article>
                            <p>
                                An array of elements of type <code class="emphasis_text">char</code> can be declared like this:
                            </p>
                            <code>
                                char v[6];<span class="tab">// array of 6 characters</span>

                            </code>
                            <p>
                                Similarly, a pointer can be declared like this:
                            </p>
                            <code>
                                char∗ p;<span class="tab">// pointer to character</span>

                            </code>
                            <p>
                                In declarations, <code class="emphasis_text">[]</code> means "array of" and <code class="emphasis_text"> * </code> means "pointer to". All arrays have <code class="emphasis_text"> 0 </code> as their lower bound, so <code class="emphasis_text"> v </code> has six elements, <code class="emphasis_text">v[0]</code> to <code class="emphasis_text">v[5]</code>. The size of an array must be a constant expression. A pointer variable can hold the address of an object of the appropriate type:
                            </p>
                            <code>
                                char∗ p = &v[3];<span class="tab">// p points to v’s four th element</span>

                                char x = ∗p;<span class="tab">// *p is the object that p points t</span>

                            </code>
                            <p>
                                In an expression, prefix unary <code class="emphasis_text"> * </code> means "contents of" and prefix unary & means "address of".<br>
                                <br>
                                Consider copying ten elements from one array to another:
                            </p>
                            <code>
                                void copy_fct()
                                {
                                    <span class="tab"></span>int v1[10] = {0,1,2,3,4,5,6,7,8,9};
                                    <span class="tab"></span>int v2[10];<span class="tab">// to become a copy of v1</span>

                                    <span class="tab"></span>for (auto i=0; i!=10; ++i) // copy elements
                                    <span class="tab"></span>v2[i]=v1[i];
                                    // ...
                                }

                            </code>
                            <p>
                                This <code class="emphasis_text">for</code>&#8211;statement can be read as "set <code class="emphasis_text"> i</code> to zero; while <code class="emphasis_text"> i</code> is not <code class="emphasis_text">10</code>, copy the ith element and increment <code class="emphasis_text"> i</code>". When applied to an integer variable, the increment operator, <code class="emphasis_text">++</code>, simply adds <code class="emphasis_text"> 1</code>. C++ also offers a simpler <code class="emphasis_text">for</code>&#8211;statement, called a range&#8211;<code class="emphasis_text">for</code>&#8211;statement, for loops that traverse a sequence in the simplest way:
                            </p>
                            <code>
                                void print()
                                {
                                    <span class="tab"></span>int v[] = {0,1,2,3,4,5,6,7,8,9};
                                
                                <span class="tab"></span>for (auto x : v)<span class="tab">// for each x in v</span>
                                <span class="tab"></span><span class="tab"></span>cout << x << '\n';
                                
                                <span class="tab"></span>for (auto x : {10,21,32,43,54,65})
                                <span class="tab"></span><span class="tab"></span>cout << x << '\n';
                                
                                <span class="tab"></span>// ...
                                }

                            </code>
                            <p>
                                The first range&#8211;<code class="emphasis_text">for</code>&#8211;statement can be read as "for every element of <code class="emphasis_text"> v</code>, from the first to the last, place a copy in <code class="emphasis_text"> x</code> and print it". Note that we don’t have to specify an array bound when we initialize it with a list. The range&#8211;<code class="emphasis_text">for</code>&#8211;statement can be used for any sequence of elements.<br>
                                <br>
                                If we didn’t want to copy the values from <code class="emphasis_text"> v</code> into the variable <code class="emphasis_text"> x</code>, but rather just have <code class="emphasis_text"> x</code> refer to an element, we could write:
                            </p>
                            <code>
                                void increment()
                                {
                                    <span class="tab"></span>int v[] = {0,1,2,3,4,5,6,7,8,9};
                                    
                                <span class="tab"></span>for (auto& x : v)
                                <span class="tab"></span><span class="tab"></span>++x;
                                <span class="tab"></span>// ...
                                }

                            </code>
                            <p>
                                In a declaration, the unary suffix <code class="emphasis_text"> &</code> means "reference to". A reference is similar to a pointer, except that you don’t need to use a prefix <code class="emphasis_text"> *</code> to access the value referred to by the reference. Also, a reference cannot be made to refer to a different object after its initialization. When used in declarations, operators (such as <code class="emphasis_text"> &</code>, <code class="emphasis_text"> *</code>, and <code class="emphasis_text">[]</code>) are called <i>declarator operators</i>:
                            </p>
                            <code>
                                T a[n];<span class="tab">// T[n]: array of n Ts</span>
                                
                                T∗ p;<span class="tab">// T*: pointer to T</span>
                                
                                T& r;<span class="tab">// T&: reference to T</span>
                                
                                T f(A);<span class="tab">// T(A): function taking an argument of type A returning a result of type T</span>

                            </code>
                            <p>
                                We try to ensure that a pointer always points to an object, so that dereferencing it is valid. When we don’t hav e an object to point to or if we need to represent the notion of "no object available" (e.g., for an end of a list), we give the pointer the value <code class="emphasis_text">nullptr</code> ("the null pointer"). There is only one <code class="emphasis_text">nullptr</code> shared by all pointer types:
                            </p>
                            <code>
                                double∗ pd = nullptr;

                                Link&lt;Record&gt;∗ lst = nullptr;<span class="tab">// pointer to a Link to a Record</span>

                                int x = nullptr;<span class="tab">// error : nullptr is a pointer not an integer</span>
                                
                            </code>
                            <p>
                                It is often wise to check that a pointer argument that is supposed to point to something, actually points to something:
                            </p>
                            <code>
                                int count_x(char∗ p, char x)
                                <span class="tab"></span><span class="tab">// count the number of occurrences of x in p[]</span>
                                <span class="tab"></span><span class="tab">// p is assumed to point to a zero-ter minated array of char (or to nothing)</span>
                                {
                                    <span class="tab"></span>(p==nullptr) return 0;
                                    <span class="tab"></span>int count = 0;
                                    <span class="tab"></span>for (; ∗p!=0; ++p)
                                    <span class="tab"></span><span class="tab"></span>if (∗p==x)
                                    <span class="tab"></span><span class="tab"></span><span class="tab"></span>++count;
                                    <span class="tab"></span>return count;
                                }

                            </code>
                            <p>
                                Note how we can move a pointer to point to the next element of an array using <code class="emphasis_text">++</code> and that we can leave out the initializer in a <code class="emphasis_text">for</code>&#8211;statement if we don’t need it.<br>
                                <br>
                                The definition of <code class="emphasis_text">count_x()</code> assumes that the <code class="emphasis_text">char∗</code> is a <i>C-style string</i>, that is, that the pointer points to a zero-terminated array of <code class="emphasis_text">char</code>.<br>
                                <br>
                                In older code, <code class="emphasis_text"> 0</code> or <code class="emphasis_text">NULL</code> is typically used instead of <code class="emphasis_text">nullptr</code>. However, using <code class="emphasis_text">nullptr</code> eliminates potential confusion between integers (such as <code class="emphasis_text"> 0</code> or <code class="emphasis_text">NULL</code>) and pointers (such as <code class="emphasis_text">nullptr</code>)
                            </p>
                        </article>
                    </section>
            
                    <section id="references" class="main-section">
                        <header>References</header>
                        <article>
                            <ul>
                                <li>The documentation in this page is taken from the book <a href="https://www.amazon.com/C-Programming-Language-4th/dp/0321563840">The C++ Programming Language, by Bjarne Stroustrup</a>.</li>
                            </ul>
                        </article>
                    </section>
                </main>
            </div>
            <footer id="footer">
                <ul>
                    <li><a href="#">Privacy</a></li>
                    <li><a href="#">Terms</a></li>
                    <li><a href="#">Contact</a></li>
                </ul>
                <p>2020 &copy; Andrea León</p>
            </footer>
        </div>